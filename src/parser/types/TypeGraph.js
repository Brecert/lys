"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const nodes_1 = require("../nodes");
const types_1 = require("../types");
const NodeError_1 = require("../NodeError");
function exists(set, delegate) {
    if (set.length == 0)
        return false;
    for (let entry of set) {
        if (delegate(entry))
            return true;
    }
    return false;
}
class TypeResolver {
    supportsPartialResolution() {
        return false;
    }
}
exports.TypeResolver = TypeResolver;
class LiteralTypeResolver extends TypeResolver {
    constructor(type) {
        super();
        this.type = type;
    }
    execute(_0, _1) {
        return this.type;
    }
}
exports.LiteralTypeResolver = LiteralTypeResolver;
class TypeGraph {
    constructor(nodes, parentGraph = null) {
        this.nodes = nodes;
        this.parentGraph = parentGraph;
        this._subGraph = new Map();
        //Set Parent to the children
        nodes.forEach($ => ($.parentGraph = this));
    }
    get rootGraph() {
        return this.parentGraph;
    }
    addSubGraph(subGraph, name) {
        this._subGraph.set(subGraph, name);
    }
    removeSubGraph(subGraph, name) {
        this._subGraph.forEach(($, $$) => {
            if ($ == name && $$ == subGraph) {
                this._subGraph.delete($$);
            }
        });
    }
    get subGraphs() {
        return this._subGraph;
    }
    findNode(astNode) {
        return (this.nodes.find(node => node.astNode == astNode) ||
            (this.parentGraph && this.parentGraph.findNode(astNode)) ||
            null);
    }
    findNodeInSubGraphs(astNode) {
        let ret = this.findNode(astNode);
        if (!ret) {
            const sg = this.subGraphs.entries();
            for (let x of sg) {
                const foundNode = x[0].findNodeInSubGraphs(astNode);
                if (foundNode) {
                    ret = foundNode;
                    break;
                }
            }
            return ret;
        }
        return ret;
    }
}
exports.TypeGraph = TypeGraph;
class TypeNode {
    constructor(astNode, typeResolver) {
        this.astNode = astNode;
        this.typeResolver = typeResolver;
        this.MAX_ATTEMPTS = 5;
        this._outgoingEdges = [];
        this._incomingEdges = [];
        this.amount = 0;
        this.parentGraph = null;
        if (!astNode) {
            throw new Error('empty astNode');
        }
    }
    execute(ctx) {
        if (this.typeResolver.supportsPartialResolution() || this.allDependenciesResolved()) {
            if (this.amount < this.MAX_ATTEMPTS) {
                this.amount = this.amount + 1;
                let resultType = this.typeResolver.execute(this, ctx);
                if (resultType) {
                    if (!this.resultType() || !resultType.equals(this.astNode.ofType)) {
                        // We only add one if the type is new
                        const newType = this.astNode instanceof nodes_1.Nodes.VariableReferenceNode ? types_1.toConcreteType(resultType, ctx) : resultType;
                        this.astNode.ofType = newType;
                        this._outgoingEdges.forEach(edge => {
                            edge.propagateType(newType, ctx);
                        });
                    }
                }
            }
            else {
                ctx.parsingContext.warning(`Unable to infer type as recursion didn't stabilize after ${this.MAX_ATTEMPTS} attempts.`, this.astNode);
            }
        }
    }
    removeOutputEdge(edge) {
        this._outgoingEdges = this._outgoingEdges.filter($ => $ != edge);
    }
    removeIncomingEdge(edge) {
        this._incomingEdges = this._incomingEdges.filter($ => $ != edge);
    }
    allDependenciesResolved() {
        return (this.incomingEdges().length == 0 ||
            this.typeResolver instanceof LiteralTypeResolver ||
            !exists(this.incomingEdges(), $ => !$.incomingTypeDefined()));
    }
    resultType() {
        return this.astNode.ofType || null;
    }
    addOutgoingEdge(edge) {
        this._outgoingEdges.push(edge);
    }
    addIncomingEdge(edge) {
        this._incomingEdges.push(edge);
    }
    outgoingEdges() {
        return this._outgoingEdges;
    }
    incomingEdges() {
        return this._incomingEdges;
    }
    incomingEdgesByName(label) {
        return this._incomingEdges.filter(edge => edge.label == label);
    }
}
exports.TypeNode = TypeNode;
class Edge {
    constructor(source, target, label = '', expected = null) {
        this.source = source;
        this.target = target;
        this.label = label;
        this.expected = expected;
        this._incomingType = null;
        this._error = false;
        source.addOutgoingEdge(this);
        target.addIncomingEdge(this);
    }
    /**
     * If this node has an error or not
     * @return
     */
    error() {
        return this._error;
    }
    /**
     * If this edge is cross different graphs
     *
     * @return
     */
    crossGraphEdge() {
        return this.source.parentGraph != this.target.parentGraph;
    }
    remove() {
        this.source.removeOutputEdge(this);
        this.target.removeIncomingEdge(this);
    }
    propagateType(actualType, ctx) {
        actualType = types_1.toConcreteType(actualType, ctx);
        if (this.expected) {
            const expectedType = types_1.toConcreteType(this.expected, ctx);
            if (!actualType.canBeAssignedTo(expectedType)) {
                this._error = true;
                this._incomingType = actualType;
                ctx.parsingContext.error(new NodeError_1.TypeMismatch(actualType, expectedType, this.source.astNode));
            }
            else {
                this._incomingType = actualType;
                ctx.currentExecutor.scheduleNode(this.target);
            }
        }
        else {
            this._incomingType = actualType;
            ctx.currentExecutor.scheduleNode(this.target);
        }
    }
    mayBeIncomingType() {
        return this._incomingType;
    }
    incomingType() {
        if (!this._incomingType)
            throw new Error('Type not defined');
        return this._incomingType;
    }
    incomingTypeDefined() {
        return !!this._incomingType;
    }
}
exports.Edge = Edge;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVHlwZUdyYXBoLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiVHlwZUdyYXBoLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsb0NBQWlDO0FBQ2pDLG9DQUFnRDtBQUVoRCw0Q0FBNEM7QUFFNUMsZ0JBQW1CLEdBQWEsRUFBRSxRQUF3QjtJQUN4RCxJQUFJLEdBQUcsQ0FBQyxNQUFNLElBQUksQ0FBQztRQUFFLE9BQU8sS0FBSyxDQUFDO0lBRWxDLEtBQUssSUFBSSxLQUFLLElBQUksR0FBRyxFQUFFO1FBQ3JCLElBQUksUUFBUSxDQUFDLEtBQUssQ0FBQztZQUFFLE9BQU8sSUFBSSxDQUFDO0tBQ2xDO0lBRUQsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDO0FBRUQ7SUFHRSx5QkFBeUI7UUFDdkIsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0NBQ0Y7QUFORCxvQ0FNQztBQUVELHlCQUFpQyxTQUFRLFlBQVk7SUFDbkQsWUFBbUIsSUFBVTtRQUMzQixLQUFLLEVBQUUsQ0FBQztRQURTLFNBQUksR0FBSixJQUFJLENBQU07SUFFN0IsQ0FBQztJQUNELE9BQU8sQ0FBQyxFQUFFLEVBQUUsRUFBRTtRQUNaLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQztJQUNuQixDQUFDO0NBQ0Y7QUFQRCxrREFPQztBQUVEO0lBR0UsWUFBbUIsS0FBc0IsRUFBUyxjQUF5QixJQUFJO1FBQTVELFVBQUssR0FBTCxLQUFLLENBQWlCO1FBQVMsZ0JBQVcsR0FBWCxXQUFXLENBQWtCO1FBRnZFLGNBQVMsR0FBMkIsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUdwRCw0QkFBNEI7UUFDNUIsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQzdDLENBQUM7SUFFRCxJQUFJLFNBQVM7UUFDWCxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7SUFDMUIsQ0FBQztJQUVE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Q1YsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhO1lBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1FBQzdELE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQztJQUM1QixDQUFDO0lBRUQsbUJBQW1CO1FBQ2pCLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUM7SUFDOUIsQ0FBQztDQUNGO0FBcEVELG9CQW9FQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGVzIH0gZnJvbSAnLi4vbm9kZXMnO1xuaW1wb3J0IHsgVHlwZSwgdG9Db25jcmV0ZVR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBUeXBlUmVzb2x1dGlvbkNvbnRleHQgfSBmcm9tICcuL1R5cGVQcm9wYWdhdG9yJztcbmltcG9ydCB7IFR5cGVNaXNtYXRjaCB9IGZyb20gJy4uL05vZGVFcnJvcic7XG5cbmZ1bmN0aW9uIGV4aXN0czxUPihzZXQ6IEFycmF5PFQ+LCBkZWxlZ2F0ZTogKFQpID0+IGJvb2xlYW4pOiBib29sZWFuIHtcbiAgaWYgKHNldC5sZW5ndGggPT0gMCkgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAobGV0IGVudHJ5IG9mIHNldCkge1xuICAgIGlmIChkZWxlZ2F0ZShlbnRyeSkpIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVHlwZVJlc29sdmVyIHtcbiAgYWJzdHJhY3QgZXhlY3V0ZShub2RlOiBUeXBlTm9kZSwgY3R4OiBUeXBlUmVzb2x1dGlvbkNvbnRleHQpOiBUeXBlIHwgbnVsbDtcblxuICBzdXBwb3J0c1BhcnRpYWxSZXNvbHV0aW9uKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTGl0ZXJhbFR5cGVSZXNvbHZlciBleHRlbmRzIFR5cGVSZXNvbHZlciB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyB0eXBlOiBUeXBlKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuICBleGVjdXRlKF8wLCBfMSkge1xuICAgIHJldHVybiB0aGlzLnR5cGU7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFR5cGVHcmFwaCB7XG4gIHByaXZhdGUgX3N1YkdyYXBoOiBNYXA8VHlwZUdyYXBoLCBzdHJpbmc+ID0gbmV3IE1hcCgpO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBub2RlczogQXJyYXk8VHlwZU5vZGU+LCBwdWJsaWMgcGFyZW50R3JhcGg6IFR5cGVHcmFwaCA9IG51bGwpIHtcbiAgICAvL1NldCBQYXJlbnQgdG8gdGhlIGNoaWxkcmVuXG4gICAgbm9kZXMuZm9yRWFjaCgkID0+ICgkLnBhcmVudEdyYXBoID0gdGhpcykpO1xuICB9XG5cbiAgZ2V0IHJvb3RHcmFwaCgpOiBUeXBlR3JhcGgge1xuICAgIHJldHVybiB0aGlzLnBhcmVudEdyYXBoO1xuICB9XG5cbiAgYWRkU3ViR3JhcGgoc3ViR3JhcGg6IFR5cGVHcmFwaCwgbmFtZTogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5fc3ViR3JhcGguc2V0KHN1YkdyYXBoLCBuYW1lKTtcbiAgfVxuXG4gIHJlbW92ZVN1YkdyYXBoKHN1YkdyYXBoOiBUeXBlR3JhcGgsIG5hbWU6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuX3N1YkdyYXBoLmZvckVhY2goKCQsICQkKSA9PiB7XG4gICAgICBpZiAoJCA9PSBuYW1lICYmICQkID09IHN1YkdyYXBoKSB7XG4gICAgICAgIHRoaXMuX3N1YkdyYXBoLmRlbGV0ZSgkJCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBnZXQgc3ViR3JhcGhzKCkge1xuICAgIHJldHVybiB0aGlzLl9zdWJHcmFwaDtcbiAgfVxuXG4gIGZpbmROb2RlKGFzdE5vZGU6IE5vZGVzLk5vZGUpOiBUeXBlTm9kZSB8IG51bGwge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLm5vZGVzLmZpbmQobm9kZSA9PiBub2RlLmFzdE5vZGUgPT0gYXN0Tm9kZSkgfHxcbiAgICAgICh0aGlzLnBhcmVudEdyYXBoICYmIHRoaXMucGFyZW50R3JhcGguZmluZE5vZGUoYXN0Tm9kZSkpIHx8XG4gICAgICBudWxsXG4gICAgKTtcbiAgfVxuXG4gIGZpbmROb2RlSW5TdWJHcmFwaHMoYXN0Tm9kZTogTm9kZXMuTm9kZSk6IFR5cGVOb2RlIHwgbnVsbCB7XG4gICAgbGV0IHJldCA9IHRoaXMuZmluZE5vZGUoYXN0Tm9kZSk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIGNvbnN0IHNnID0gdGhpcy5zdWJHcmFwaHMuZW50cmllcygpO1xuICAgICAgZm9yIChsZXQgeCBvZiBzZykge1xuICAgICAgICBjb25zdCBmb3VuZE5vZGUgPSB4WzBdLmZpbmROb2RlSW5TdWJHcmFwaHMoYXN0Tm9kZSk7XG4gICAgICAgIGlmIChmb3VuZE5vZGUpIHtcbiAgICAgICAgICByZXQgPSBmb3VuZE5vZGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFR5cGVOb2RlIHtcbiAgY29uc3RydWN0b3IocHVibGljIGFzdE5vZGU6IE5vZGVzLk5vZGUsIHB1YmxpYyB0eXBlUmVzb2x2ZXI6IFR5cGVSZXNvbHZlcikge1xuICAgIGlmICghYXN0Tm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbXB0eSBhc3ROb2RlJyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBNQVhfQVRURU1QVFMgPSA1O1xuICBwcml2YXRlIF9vdXRnb2luZ0VkZ2VzOiBBcnJheTxFZGdlPiA9IFtdO1xuICBwcml2YXRlIF9pbmNvbWluZ0VkZ2VzOiBBcnJheTxFZGdlPiA9IFtdO1xuICBwcml2YXRlIGFtb3VudCA9IDA7XG5cbiAgcGFyZW50R3JhcGg6IFR5cGVHcmFwaCB8IG51bGwgPSBudWxsO1xuXG4gIGV4ZWN1dGUoY3R4OiBUeXBlUmVzb2x1dGlvbkNvbnRleHQpOiB2b2lkIHtcbiAgICBpZiAodGhpcy50eXBlUmVzb2x2ZXIuc3VwcG9ydHNQYXJ0aWFsUmVzb2x1dGlvbigpIHx8IHRoaXMuYWxsRGVwZW5kZW5jaWVzUmVzb2x2ZWQoKSkge1xuICAgICAgaWYgKHRoaXMuYW1vdW50IDwgdGhpcy5NQVhfQVRURU1QVFMpIHtcbiAgICAgICAgdGhpcy5hbW91bnQgPSB0aGlzLmFtb3VudCArIDE7XG4gICAgICAgIGxldCByZXN1bHRUeXBlOiBUeXBlIHwgbnVsbCA9IHRoaXMudHlwZVJlc29sdmVyLmV4ZWN1dGUodGhpcywgY3R4KTtcblxuICAgICAgICBpZiAocmVzdWx0VHlwZSkge1xuICAgICAgICAgIGlmICghdGhpcy5yZXN1bHRUeXBlKCkgfHwgIXJlc3VsdFR5cGUuZXF1YWxzKHRoaXMuYXN0Tm9kZS5vZlR5cGUpKSB7XG4gICAgICAgICAgICAvLyBXZSBvbmx5IGFkZCBvbmUgaWYgdGhlIHR5cGUgaXMgbmV3XG4gICAgICAgICAgICBjb25zdCBuZXdUeXBlID1cbiAgICAgICAgICAgICAgdGhpcy5hc3ROb2RlIGluc3RhbmNlb2YgTm9kZXMuVmFyaWFibGVSZWZlcmVuY2VOb2RlID8gdG9Db25jcmV0ZVR5cGUocmVzdWx0VHlwZSwgY3R4KSA6IHJlc3VsdFR5cGU7XG5cbiAgICAgICAgICAgIHRoaXMuYXN0Tm9kZS5vZlR5cGUgPSBuZXdUeXBlO1xuXG4gICAgICAgICAgICB0aGlzLl9vdXRnb2luZ0VkZ2VzLmZvckVhY2goZWRnZSA9PiB7XG4gICAgICAgICAgICAgIGVkZ2UucHJvcGFnYXRlVHlwZShuZXdUeXBlLCBjdHgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHgucGFyc2luZ0NvbnRleHQud2FybmluZyhcbiAgICAgICAgICBgVW5hYmxlIHRvIGluZmVyIHR5cGUgYXMgcmVjdXJzaW9uIGRpZG4ndCBzdGFiaWxpemUgYWZ0ZXIgJHt0aGlzLk1BWF9BVFRFTVBUU30gYXR0ZW1wdHMuYCxcbiAgICAgICAgICB0aGlzLmFzdE5vZGVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZW1vdmVPdXRwdXRFZGdlKGVkZ2U6IEVkZ2UpOiB2b2lkIHtcbiAgICB0aGlzLl9vdXRnb2luZ0VkZ2VzID0gdGhpcy5fb3V0Z29pbmdFZGdlcy5maWx0ZXIoJCA9PiAkICE9IGVkZ2UpO1xuICB9XG5cbiAgcmVtb3ZlSW5jb21pbmdFZGdlKGVkZ2U6IEVkZ2UpOiB2b2lkIHtcbiAgICB0aGlzLl9pbmNvbWluZ0VkZ2VzID0gdGhpcy5faW5jb21pbmdFZGdlcy5maWx0ZXIoJCA9PiAkICE9IGVkZ2UpO1xuICB9XG5cbiAgYWxsRGVwZW5kZW5jaWVzUmVzb2x2ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuaW5jb21pbmdFZGdlcygpLmxlbmd0aCA9PSAwIHx8XG4gICAgICB0aGlzLnR5cGVSZXNvbHZlciBpbnN0YW5jZW9mIExpdGVyYWxUeXBlUmVzb2x2ZXIgfHxcbiAgICAgICFleGlzdHModGhpcy5pbmNvbWluZ0VkZ2VzKCksICQgPT4gISQuaW5jb21pbmdUeXBlRGVmaW5lZCgpKVxuICAgICk7XG4gIH1cblxuICByZXN1bHRUeXBlKCk6IFR5cGUgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5hc3ROb2RlLm9mVHlwZSB8fCBudWxsO1xuICB9XG5cbiAgYWRkT3V0Z29pbmdFZGdlKGVkZ2U6IEVkZ2UpOiB2b2lkIHtcbiAgICB0aGlzLl9vdXRnb2luZ0VkZ2VzLnB1c2goZWRnZSk7XG4gIH1cblxuICBhZGRJbmNvbWluZ0VkZ2UoZWRnZTogRWRnZSk6IHZvaWQge1xuICAgIHRoaXMuX2luY29taW5nRWRnZXMucHVzaChlZGdlKTtcbiAgfVxuXG4gIG91dGdvaW5nRWRnZXMoKTogQXJyYXk8RWRnZT4ge1xuICAgIHJldHVybiB0aGlzLl9vdXRnb2luZ0VkZ2VzO1xuICB9XG5cbiAgaW5jb21pbmdFZGdlcygpOiBBcnJheTxFZGdlPiB7XG4gICAgcmV0dXJuIHRoaXMuX2luY29taW5nRWRnZXM7XG4gIH1cblxuICBpbmNvbWluZ0VkZ2VzQnlOYW1lKGxhYmVsOiBzdHJpbmcpOiBBcnJheTxFZGdlPiB7XG4gICAgcmV0dXJuIHRoaXMuX2luY29taW5nRWRnZXMuZmlsdGVyKGVkZ2UgPT4gZWRnZS5sYWJlbCA9PSBsYWJlbCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEVkZ2Uge1xuICBwcml2YXRlIF9pbmNvbWluZ1R5cGU6IFR5cGUgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBfZXJyb3IgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgc291cmNlOiBUeXBlTm9kZSxcbiAgICBwdWJsaWMgdGFyZ2V0OiBUeXBlTm9kZSxcbiAgICBwdWJsaWMgbGFiZWw6IHN0cmluZyA9ICcnLFxuICAgIHB1YmxpYyBleHBlY3RlZDogVHlwZSB8IG51bGwgPSBudWxsXG4gICkge1xuICAgIHNvdXJjZS5hZGRPdXRnb2luZ0VkZ2UodGhpcyk7XG4gICAgdGFyZ2V0LmFkZEluY29taW5nRWRnZSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGlzIG5vZGUgaGFzIGFuIGVycm9yIG9yIG5vdFxuICAgKiBAcmV0dXJuXG4gICAqL1xuICBlcnJvcigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhpcyBlZGdlIGlzIGNyb3NzIGRpZmZlcmVudCBncmFwaHNcbiAgICpcbiAgICogQHJldHVyblxuICAgKi9cbiAgY3Jvc3NHcmFwaEVkZ2UoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlLnBhcmVudEdyYXBoICE9IHRoaXMudGFyZ2V0LnBhcmVudEdyYXBoO1xuICB9XG5cbiAgcmVtb3ZlKCk6IHZvaWQge1xuICAgIHRoaXMuc291cmNlLnJlbW92ZU91dHB1dEVkZ2UodGhpcyk7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlSW5jb21pbmdFZGdlKHRoaXMpO1xuICB9XG5cbiAgcHJvcGFnYXRlVHlwZShhY3R1YWxUeXBlOiBUeXBlLCBjdHg6IFR5cGVSZXNvbHV0aW9uQ29udGV4dCk6IHZvaWQge1xuICAgIGFjdHVhbFR5cGUgPSB0b0NvbmNyZXRlVHlwZShhY3R1YWxUeXBlLCBjdHgpO1xuXG4gICAgaWYgKHRoaXMuZXhwZWN0ZWQpIHtcbiAgICAgIGNvbnN0IGV4cGVjdGVkVHlwZTogVHlwZSA9IHRvQ29uY3JldGVUeXBlKHRoaXMuZXhwZWN0ZWQsIGN0eCk7XG5cbiAgICAgIGlmICghYWN0dWFsVHlwZS5jYW5CZUFzc2lnbmVkVG8oZXhwZWN0ZWRUeXBlKSkge1xuICAgICAgICB0aGlzLl9lcnJvciA9IHRydWU7XG4gICAgICAgIHRoaXMuX2luY29taW5nVHlwZSA9IGFjdHVhbFR5cGU7XG4gICAgICAgIGN0eC5wYXJzaW5nQ29udGV4dC5lcnJvcihuZXcgVHlwZU1pc21hdGNoKGFjdHVhbFR5cGUsIGV4cGVjdGVkVHlwZSwgdGhpcy5zb3VyY2UuYXN0Tm9kZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faW5jb21pbmdUeXBlID0gYWN0dWFsVHlwZTtcbiAgICAgICAgY3R4LmN1cnJlbnRFeGVjdXRvci5zY2hlZHVsZU5vZGUodGhpcy50YXJnZXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pbmNvbWluZ1R5cGUgPSBhY3R1YWxUeXBlO1xuICAgICAgY3R4LmN1cnJlbnRFeGVjdXRvci5zY2hlZHVsZU5vZGUodGhpcy50YXJnZXQpO1xuICAgIH1cbiAgfVxuXG4gIG1heUJlSW5jb21pbmdUeXBlKCk6IFR5cGUgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5faW5jb21pbmdUeXBlO1xuICB9XG5cbiAgaW5jb21pbmdUeXBlKCk6IFR5cGUgfCBudWxsIHtcbiAgICBpZiAoIXRoaXMuX2luY29taW5nVHlwZSkgdGhyb3cgbmV3IEVycm9yKCdUeXBlIG5vdCBkZWZpbmVkJyk7XG4gICAgcmV0dXJuIHRoaXMuX2luY29taW5nVHlwZTtcbiAgfVxuXG4gIGluY29taW5nVHlwZURlZmluZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhdGhpcy5faW5jb21pbmdUeXBlO1xuICB9XG59XG4iXX0=