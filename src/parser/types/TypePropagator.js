"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("../types");
const TypeGraphBuilder_1 = require("./TypeGraphBuilder");
function top(stack) {
    if (stack.length) {
        return stack[stack.length - 1];
    }
    return null;
}
class TypeResolutionContext {
    constructor(rootGraph, parsingContext) {
        this.rootGraph = rootGraph;
        this.parsingContext = parsingContext;
        this._executors = new Array();
        this._functionSubGraphs = new Array();
    }
    newExecutorWithContext(scope, dataGraph, parsingContext) {
        const propagator = new TypePropagator(this);
        this._executors.push({ dataGraph, propagator, scope, parsingContext });
        return propagator;
    }
    endContext() {
        this._executors.pop();
    }
    /**
     * Returns the current executor that is being used for execution of the graph
     *
     * @return
     */
    get currentExecutor() {
        return top(this._executors).propagator;
    }
    /**
     * Returns the graph that is being currently under execution
     *
     * @return
     */
    get currentGraph() {
        return top(this._executors).dataGraph;
    }
    /**
     * Return the
     *
     * @return
     */
    get currentScopeNavigator() {
        return top(this._executors).scope;
    }
    get currentParsingContext() {
        return top(this._executors).parsingContext;
    }
    getFunctionSubGraph(functionNode, parameterTypes) {
        const x = this.getFunctionGraph(functionNode);
        if (x) {
            const ret = x.find(graph => this.matches(graph.seq, parameterTypes));
            if (!ret)
                return null;
            return ret.graph;
        }
        return null;
    }
    getFunctionGraph(functionNode) {
        const ret = this._functionSubGraphs.find($ => $.functionNode == functionNode);
        if (!ret)
            return null;
        return ret.list;
    }
    matches(expected, actual) {
        if (expected.length == actual.length) {
            return !expected.some((type, $$) => !type.equals(actual[$$]));
        }
        else {
            return false;
        }
    }
    removeFunctionSubGraph(functionNode, parameterTypes, _graph) {
        const x = this.getFunctionGraph(functionNode);
        if (x) {
            const theFn = x.findIndex(graph => graph.graph === _graph || this.matches(graph.seq, parameterTypes));
            x.splice(theFn, 1);
        }
    }
    addFunctionSubGraph(functionNode, parameterTypes, graph) {
        const x = this.getFunctionGraph(functionNode);
        if (x) {
            x.push({ seq: parameterTypes, graph });
        }
        else {
            this._functionSubGraphs.push({
                functionNode,
                list: [{ seq: parameterTypes, graph }]
            });
        }
    }
}
exports.TypeResolutionContext = TypeResolutionContext;
class TypePropagator {
    constructor(ctx) {
        this.ctx = ctx;
        this.executionStack = [];
    }
    scheduleNode(node) {
        if (!this.executionStack.some(n => n == node)) {
            this.executionStack.push(node);
        }
    }
    start() {
        while (this.executionStack.length !== 0) {
            const nodeToExecute = this.executionStack.pop();
            nodeToExecute.execute(this.ctx);
        }
    }
    scheduleNodes() {
        this.ctx.currentGraph.nodes.forEach(node => {
            if (!node.allDependenciesResolved()) {
                const incomingEdges = node.incomingEdges();
                if (incomingEdges.some($ => $.crossGraphEdge())) {
                    const crossGraph = incomingEdges.filter(edge => edge.crossGraphEdge());
                    crossGraph.forEach($ => this.scheduleDependencies($, []));
                }
            }
        });
        this.ctx.currentGraph.nodes.forEach(node => {
            if (node.allDependenciesResolved()) {
                this.scheduleNode(node);
            }
        });
    }
    scheduleDependencies(edge, stack) {
        if (!edge.incomingTypeDefined()) {
            if (edge.source.resultType()) {
                edge.propagateType(edge.source.resultType(), this.ctx);
            }
            else if (edge.source.incomingEdges().length == 0) {
                this.scheduleNode(edge.source);
            }
            else {
                if (!stack.includes(edge.source)) {
                    stack.push(edge.source);
                    edge.source.incomingEdges().forEach(incomingEdge => {
                        //Avoid self reference loop
                        if (incomingEdge.source != edge.target) {
                            this.scheduleDependencies(incomingEdge, stack);
                        }
                    });
                    stack.pop();
                }
            }
        }
        else {
            this.ctx.currentExecutor.scheduleNode(edge.target);
        }
    }
    run() {
        this.scheduleNodes();
        this.start();
        this.ctx.endContext();
    }
}
exports.TypePropagator = TypePropagator;
function resolveReturnType(typeGraph, functionNode, argTypes, ctx) {
    const subGraph = ctx.getFunctionSubGraph(functionNode, argTypes);
    if (subGraph) {
        const result = subGraph.findNode(functionNode).resultType();
        if (result instanceof types_1.FunctionType) {
            // THIS SHOULD NOT HAPPEN
            return result.returnType;
        }
        return result;
    }
    else {
        const context = ctx.currentParsingContext;
        const dataGraphBuilder = new TypeGraphBuilder_1.TypeGraphBuilder(ctx.parsingContext, typeGraph);
        const dataGraph = dataGraphBuilder.buildFunctionNode(functionNode, argTypes);
        ctx.addFunctionSubGraph(functionNode, argTypes, dataGraph);
        const functionName = functionNode.functionName.name + '(' + argTypes.join(',') + ')';
        ctx.rootGraph.addSubGraph(dataGraph, functionName);
        ctx.newExecutorWithContext(functionNode.closure, dataGraph, context).run();
        const value = dataGraph.findNode(functionNode);
        const result = value.resultType();
        if (!result || ctx.parsingContext.hasErrors()) {
            ctx.removeFunctionSubGraph(functionNode, argTypes, dataGraph);
            ctx.rootGraph.removeSubGraph(dataGraph, functionName);
        }
        if (result instanceof types_1.FunctionType) {
            // THIS SHOULD NOT HAPPEN
            return result.returnType;
        }
        return result;
    }
}
exports.resolveReturnType = resolveReturnType;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVHlwZVByb3BhZ2F0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJUeXBlUHJvcGFnYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUdBLG9DQUE4QztBQUM5Qyx5REFBc0Q7QUFFdEQsYUFBZ0IsS0FBZTtJQUM3QixJQUFJLEtBQUssQ0FBQyxNQUFNLEVBQUU7UUFDaEIsT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztLQUNoQztJQUNELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQztBQUVEO0lBQ0UsWUFBbUIsU0FBb0IsRUFBUyxjQUE4QjtRQUEzRCxjQUFTLEdBQVQsU0FBUyxDQUFXO1FBQVMsbUJBQWMsR0FBZCxjQUFjLENBQWdCO1FBRXRFLGVBQVUsR0FBRyxJQUFJLEtBQUssRUFLMUIsQ0FBQztRQUVHLHVCQUFrQixHQUFHLElBQUksS0FBSyxFQUdsQyxDQUFDO0lBWjRFLENBQUM7SUFjbEYsc0JBQXNCLENBQUMsS0FBYyxFQUFFLFNBQW9CLEVBQUUsY0FBOEI7UUFDekYsTUFBTSxVQUFVLEdBQW1CLElBQUksY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzVELElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUUsY0FBYyxFQUFFLENBQUMsQ0FBQztRQUN2RSxPQUFPLFVBQVUsQ0FBQztJQUNwQixDQUFDO0lBRUQsVUFBVTtRQUNSLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDeEIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxJQUFJLGVBQWU7UUFDakIsT0FBTyxHQUFHLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLFVBQVUsQ0FBQztJQUN6QyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILElBQUksWUFBWTtRQUNkLE9BQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxTQUFTLENBQUM7SUFDeEMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxJQUFJLHFCQUFxQjtRQUN2QixPQUFPLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsS0FBSyxDQUFDO0lBQ3BDLENBQUM7SUFFRCxJQUFJLHFCQUFxQjtRQUN2QixPQUFPLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsY0FBYyxDQUFDO0lBQzdDLENBQUM7SUFFRCxtQkFBbUIsQ0FBQyxZQUFnQyxFQUFFLGNBQTJCO1FBQy9FLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUM5QyxJQUFJLENBQUMsRUFBRTtZQUNMLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsY0FBYyxDQUFDLENBQUMsQ0FBQztZQUNyRSxJQUFJLENBQUMsR0FBRztnQkFBRSxPQUFPLElBQUksQ0FBQztZQUN0QixPQUFPLEdBQUcsQ0FBQyxLQUFLLENBQUM7U0FDbEI7UUFDRCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRCxnQkFBZ0IsQ0FBQyxZQUFnQztRQUMvQyxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFlBQVksSUFBSSxZQUFZLENBQUMsQ0FBQztRQUM5RSxJQUFJLENBQUMsR0FBRztZQUFFLE9BQU8sSUFBSSxDQUFDO1FBQ3RCLE9BQU8sR0FBRyxDQUFDLElBQUksQ0FBQztJQUNsQixDQUFDO0lBRU8sT0FBTyxDQUFDLFFBQXFCLEVBQUUsTUFBbUI7UUFDeEQsSUFBSSxRQUFRLENBQUMsTUFBTSxJQUFJLE1BQU0sQ0FBQyxNQUFNLEVBQUU7WUFDcEMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUMvRDthQUFNO1lBQ0wsT0FBTyxLQUFLLENBQUM7U0FDZDtJQUNILENBQUM7SUFFRCxzQkFBc0IsQ0FBQyxZQUFnQyxFQUFFLGNBQTJCLEVBQUUsTUFBaUI7UUFDckcsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQzlDLElBQUksQ0FBQyxFQUFFO1lBQ0wsTUFBTSxLQUFLLEdBQUcsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxLQUFLLEtBQUssTUFBTSxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDO1lBQ3RHLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQ3BCO0lBQ0gsQ0FBQztJQUVELG1CQUFtQixDQUFDLFlBQWdDLEVBQUUsY0FBc0IsRUFBRSxLQUFnQjtRQUM1RixNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsWUFBWSxDQUFDLENBQUM7UUFFOUMsSUFBSSxDQUFDLEVBQUU7WUFDTCxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLGNBQWMsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO1NBQ3hDO2FBQU07WUFDTCxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDO2dCQUMzQixZQUFZO2dCQUNaLElBQUksRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLGNBQWMsRUFBRSxLQUFLLEVBQUUsQ0FBQzthQUN2QyxDQUFDLENBQUM7U0FDSjtJQUNILENBQUM7Q0FDRjtBQXBHRCxzREFvR0M7QUFFRDtJQUVFLFlBQW1CLEdBQTBCO1FBQTFCLFFBQUcsR0FBSCxHQUFHLENBQXVCO1FBRDdDLG1CQUFjLEdBQW9CLEVBQUUsQ0FBQztJQUNXLENBQUM7SUFFakQsWUFBWSxDQUFDLElBQWM7UUFDekIsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxFQUFFO1lBQzdDLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ2hDO0lBQ0gsQ0FBQztJQUVPLEtBQUs7UUFDWCxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUN2QyxNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQ2hELGFBQWEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ2pDO0lBQ0gsQ0FBQztJQUVPLGFBQWE7UUFDbkIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUN6QyxJQUFJLENBQUMsSUFBSSxDQUFDLHVCQUF1QixFQUFFLEVBQUU7Z0JBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztnQkFFM0MsSUFBSSxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLGNBQWMsRUFBRSxDQUFDLEVBQUU7b0JBQy9DLE1BQU0sVUFBVSxHQUFHLGFBQWEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUMsQ0FBQztvQkFDdkUsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztpQkFDM0Q7YUFDRjtRQUNILENBQUMsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUN6QyxJQUFJLElBQUksQ0FBQyx1QkFBdUIsRUFBRSxFQUFFO2dCQUNsQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3pCO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRU8sb0JBQW9CLENBQUMsSUFBVSxFQUFFLEtBQXNCO1FBQzdELElBQUksQ0FBQyxJQUFJLENBQUMsbUJBQW1CLEVBQUUsRUFBRTtZQUMvQixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxFQUFFLEVBQUU7Z0JBQzVCLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7YUFDeEQ7aUJBQU0sSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLGFBQWEsRUFBRSxDQUFDLE1BQU0sSUFBSSxDQUFDLEVBQUU7Z0JBQ2xELElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQ2hDO2lCQUFNO2dCQUNMLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRTtvQkFDaEMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7b0JBQ3hCLElBQUksQ0FBQyxNQUFNLENBQUMsYUFBYSxFQUFFLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxFQUFFO3dCQUNqRCwyQkFBMkI7d0JBQzNCLElBQUksWUFBWSxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFOzRCQUN0QyxJQUFJLENBQUMsb0JBQW9CLENBQUMsWUFBWSxFQUFFLEtBQUssQ0FBQyxDQUFDO3lCQUNoRDtvQkFDSCxDQUFDLENBQUMsQ0FBQztvQkFDSCxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUM7aUJBQ2I7YUFDRjtTQUNGO2FBQU07WUFDTCxJQUFJLENBQUMsR0FBRyxDQUFDLGVBQWUsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ3BEO0lBQ0gsQ0FBQztJQUVELEdBQUc7UUFDRCxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7UUFDckIsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ2IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLEVBQUUsQ0FBQztJQUN4QixDQUFDO0NBQ0Y7QUEvREQsd0NBK0RDO0FBRUQsMkJBQ0UsU0FBb0IsRUFDcEIsWUFBZ0MsRUFDaEMsUUFBZ0IsRUFDaEIsR0FBMEI7SUFFMUIsTUFBTSxRQUFRLEdBQWMsR0FBRyxDQUFDLG1CQUFtQixDQUFDLFlBQVksRUFBRSxRQUFRLENBQUMsQ0FBQztJQUU1RSxJQUFJLFFBQVEsRUFBRTtRQUNaLE1BQU0sTUFBTSxHQUFHLFFBQVEsQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDNUQsSUFBSSxNQUFNLFlBQVksb0JBQVksRUFBRTtZQUNsQyx5QkFBeUI7WUFDekIsT0FBTyxNQUFNLENBQUMsVUFBVSxDQUFDO1NBQzFCO1FBQ0QsT0FBTyxNQUFNLENBQUM7S0FDZjtTQUFNO1FBQ0wsTUFBTSxPQUFPLEdBQUcsR0FBRyxDQUFDLHFCQUFxQixDQUFDO1FBRTFDLE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxtQ0FBZ0IsQ0FBQyxHQUFHLENBQUMsY0FBYyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBRTdFLE1BQU0sU0FBUyxHQUFjLGdCQUFnQixDQUFDLGlCQUFpQixDQUFDLFlBQVksRUFBRSxRQUFRLENBQUMsQ0FBQztRQUV4RixHQUFHLENBQUMsbUJBQW1CLENBQUMsWUFBWSxFQUFFLFFBQVEsRUFBRSxTQUFTLENBQUMsQ0FBQztRQUMzRCxNQUFNLFlBQVksR0FBRyxZQUFZLENBQUMsWUFBWSxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUM7UUFDckYsR0FBRyxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsU0FBUyxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQ25ELEdBQUcsQ0FBQyxzQkFBc0IsQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUMzRSxNQUFNLEtBQUssR0FBRyxTQUFTLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBRS9DLE1BQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUVsQyxJQUFJLENBQUMsTUFBTSxJQUFJLEdBQUcsQ0FBQyxjQUFjLENBQUMsU0FBUyxFQUFFLEVBQUU7WUFDN0MsR0FBRyxDQUFDLHNCQUFzQixDQUFDLFlBQVksRUFBRSxRQUFRLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFDOUQsR0FBRyxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsU0FBUyxFQUFFLFlBQVksQ0FBQyxDQUFDO1NBQ3ZEO1FBQ0QsSUFBSSxNQUFNLFlBQVksb0JBQVksRUFBRTtZQUNsQyx5QkFBeUI7WUFDekIsT0FBTyxNQUFNLENBQUMsVUFBVSxDQUFDO1NBQzFCO1FBQ0QsT0FBTyxNQUFNLENBQUM7S0FDZjtBQUNILENBQUM7QUF4Q0QsOENBd0NDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVHlwZUdyYXBoLCBUeXBlTm9kZSwgRWRnZSB9IGZyb20gJy4vVHlwZUdyYXBoJztcbmltcG9ydCB7IFBhcnNpbmdDb250ZXh0LCBDbG9zdXJlIH0gZnJvbSAnLi4vY2xvc3VyZSc7XG5pbXBvcnQgeyBOb2RlcyB9IGZyb20gJy4uL25vZGVzJztcbmltcG9ydCB7IFR5cGUsIEZ1bmN0aW9uVHlwZSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IFR5cGVHcmFwaEJ1aWxkZXIgfSBmcm9tICcuL1R5cGVHcmFwaEJ1aWxkZXInO1xuXG5mdW5jdGlvbiB0b3A8VD4oc3RhY2s6IEFycmF5PFQ+KTogVCB8IG51bGwge1xuICBpZiAoc3RhY2subGVuZ3RoKSB7XG4gICAgcmV0dXJuIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgY2xhc3MgVHlwZVJlc29sdXRpb25Db250ZXh0IHtcbiAgY29uc3RydWN0b3IocHVibGljIHJvb3RHcmFwaDogVHlwZUdyYXBoLCBwdWJsaWMgcGFyc2luZ0NvbnRleHQ6IFBhcnNpbmdDb250ZXh0KSB7fVxuXG4gIHByaXZhdGUgX2V4ZWN1dG9ycyA9IG5ldyBBcnJheTx7XG4gICAgZGF0YUdyYXBoOiBUeXBlR3JhcGg7XG4gICAgcHJvcGFnYXRvcjogVHlwZVByb3BhZ2F0b3I7XG4gICAgc2NvcGU6IENsb3N1cmU7XG4gICAgcGFyc2luZ0NvbnRleHQ6IFBhcnNpbmdDb250ZXh0O1xuICB9PigpO1xuXG4gIHByaXZhdGUgX2Z1bmN0aW9uU3ViR3JhcGhzID0gbmV3IEFycmF5PHtcbiAgICBmdW5jdGlvbk5vZGU6IE5vZGVzLkZ1bmN0aW9uTm9kZTtcbiAgICBsaXN0OiBBcnJheTx7IHNlcTogQXJyYXk8VHlwZT47IGdyYXBoOiBUeXBlR3JhcGggfT47XG4gIH0+KCk7XG5cbiAgbmV3RXhlY3V0b3JXaXRoQ29udGV4dChzY29wZTogQ2xvc3VyZSwgZGF0YUdyYXBoOiBUeXBlR3JhcGgsIHBhcnNpbmdDb250ZXh0OiBQYXJzaW5nQ29udGV4dCk6IFR5cGVQcm9wYWdhdG9yIHtcbiAgICBjb25zdCBwcm9wYWdhdG9yOiBUeXBlUHJvcGFnYXRvciA9IG5ldyBUeXBlUHJvcGFnYXRvcih0aGlzKTtcbiAgICB0aGlzLl9leGVjdXRvcnMucHVzaCh7IGRhdGFHcmFwaCwgcHJvcGFnYXRvciwgc2NvcGUsIHBhcnNpbmdDb250ZXh0IH0pO1xuICAgIHJldHVybiBwcm9wYWdhdG9yO1xuICB9XG5cbiAgZW5kQ29udGV4dCgpOiB2b2lkIHtcbiAgICB0aGlzLl9leGVjdXRvcnMucG9wKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBleGVjdXRvciB0aGF0IGlzIGJlaW5nIHVzZWQgZm9yIGV4ZWN1dGlvbiBvZiB0aGUgZ3JhcGhcbiAgICpcbiAgICogQHJldHVyblxuICAgKi9cbiAgZ2V0IGN1cnJlbnRFeGVjdXRvcigpOiBUeXBlUHJvcGFnYXRvciB7XG4gICAgcmV0dXJuIHRvcCh0aGlzLl9leGVjdXRvcnMpLnByb3BhZ2F0b3I7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZ3JhcGggdGhhdCBpcyBiZWluZyBjdXJyZW50bHkgdW5kZXIgZXhlY3V0aW9uXG4gICAqXG4gICAqIEByZXR1cm5cbiAgICovXG4gIGdldCBjdXJyZW50R3JhcGgoKTogVHlwZUdyYXBoIHtcbiAgICByZXR1cm4gdG9wKHRoaXMuX2V4ZWN1dG9ycykuZGF0YUdyYXBoO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGVcbiAgICpcbiAgICogQHJldHVyblxuICAgKi9cbiAgZ2V0IGN1cnJlbnRTY29wZU5hdmlnYXRvcigpOiBDbG9zdXJlIHtcbiAgICByZXR1cm4gdG9wKHRoaXMuX2V4ZWN1dG9ycykuc2NvcGU7XG4gIH1cblxuICBnZXQgY3VycmVudFBhcnNpbmdDb250ZXh0KCk6IFBhcnNpbmdDb250ZXh0IHtcbiAgICByZXR1cm4gdG9wKHRoaXMuX2V4ZWN1dG9ycykucGFyc2luZ0NvbnRleHQ7XG4gIH1cblxuICBnZXRGdW5jdGlvblN1YkdyYXBoKGZ1bmN0aW9uTm9kZTogTm9kZXMuRnVuY3Rpb25Ob2RlLCBwYXJhbWV0ZXJUeXBlczogQXJyYXk8VHlwZT4pOiBUeXBlR3JhcGggfCBudWxsIHtcbiAgICBjb25zdCB4ID0gdGhpcy5nZXRGdW5jdGlvbkdyYXBoKGZ1bmN0aW9uTm9kZSk7XG4gICAgaWYgKHgpIHtcbiAgICAgIGNvbnN0IHJldCA9IHguZmluZChncmFwaCA9PiB0aGlzLm1hdGNoZXMoZ3JhcGguc2VxLCBwYXJhbWV0ZXJUeXBlcykpO1xuICAgICAgaWYgKCFyZXQpIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIHJldC5ncmFwaDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXRGdW5jdGlvbkdyYXBoKGZ1bmN0aW9uTm9kZTogTm9kZXMuRnVuY3Rpb25Ob2RlKTogbnVsbCB8IEFycmF5PHsgc2VxOiBBcnJheTxUeXBlPjsgZ3JhcGg6IFR5cGVHcmFwaCB9PiB7XG4gICAgY29uc3QgcmV0ID0gdGhpcy5fZnVuY3Rpb25TdWJHcmFwaHMuZmluZCgkID0+ICQuZnVuY3Rpb25Ob2RlID09IGZ1bmN0aW9uTm9kZSk7XG4gICAgaWYgKCFyZXQpIHJldHVybiBudWxsO1xuICAgIHJldHVybiByZXQubGlzdDtcbiAgfVxuXG4gIHByaXZhdGUgbWF0Y2hlcyhleHBlY3RlZDogQXJyYXk8VHlwZT4sIGFjdHVhbDogQXJyYXk8VHlwZT4pOiBib29sZWFuIHtcbiAgICBpZiAoZXhwZWN0ZWQubGVuZ3RoID09IGFjdHVhbC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAhZXhwZWN0ZWQuc29tZSgodHlwZSwgJCQpID0+ICF0eXBlLmVxdWFscyhhY3R1YWxbJCRdKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZW1vdmVGdW5jdGlvblN1YkdyYXBoKGZ1bmN0aW9uTm9kZTogTm9kZXMuRnVuY3Rpb25Ob2RlLCBwYXJhbWV0ZXJUeXBlczogQXJyYXk8VHlwZT4sIF9ncmFwaDogVHlwZUdyYXBoKTogdm9pZCB7XG4gICAgY29uc3QgeCA9IHRoaXMuZ2V0RnVuY3Rpb25HcmFwaChmdW5jdGlvbk5vZGUpO1xuICAgIGlmICh4KSB7XG4gICAgICBjb25zdCB0aGVGbiA9IHguZmluZEluZGV4KGdyYXBoID0+IGdyYXBoLmdyYXBoID09PSBfZ3JhcGggfHwgdGhpcy5tYXRjaGVzKGdyYXBoLnNlcSwgcGFyYW1ldGVyVHlwZXMpKTtcbiAgICAgIHguc3BsaWNlKHRoZUZuLCAxKTtcbiAgICB9XG4gIH1cblxuICBhZGRGdW5jdGlvblN1YkdyYXBoKGZ1bmN0aW9uTm9kZTogTm9kZXMuRnVuY3Rpb25Ob2RlLCBwYXJhbWV0ZXJUeXBlczogVHlwZVtdLCBncmFwaDogVHlwZUdyYXBoKTogdm9pZCB7XG4gICAgY29uc3QgeCA9IHRoaXMuZ2V0RnVuY3Rpb25HcmFwaChmdW5jdGlvbk5vZGUpO1xuXG4gICAgaWYgKHgpIHtcbiAgICAgIHgucHVzaCh7IHNlcTogcGFyYW1ldGVyVHlwZXMsIGdyYXBoIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9mdW5jdGlvblN1YkdyYXBocy5wdXNoKHtcbiAgICAgICAgZnVuY3Rpb25Ob2RlLFxuICAgICAgICBsaXN0OiBbeyBzZXE6IHBhcmFtZXRlclR5cGVzLCBncmFwaCB9XVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBUeXBlUHJvcGFnYXRvciB7XG4gIGV4ZWN1dGlvblN0YWNrOiBBcnJheTxUeXBlTm9kZT4gPSBbXTtcbiAgY29uc3RydWN0b3IocHVibGljIGN0eDogVHlwZVJlc29sdXRpb25Db250ZXh0KSB7fVxuXG4gIHNjaGVkdWxlTm9kZShub2RlOiBUeXBlTm9kZSk6IHZvaWQge1xuICAgIGlmICghdGhpcy5leGVjdXRpb25TdGFjay5zb21lKG4gPT4gbiA9PSBub2RlKSkge1xuICAgICAgdGhpcy5leGVjdXRpb25TdGFjay5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc3RhcnQoKTogdm9pZCB7XG4gICAgd2hpbGUgKHRoaXMuZXhlY3V0aW9uU3RhY2subGVuZ3RoICE9PSAwKSB7XG4gICAgICBjb25zdCBub2RlVG9FeGVjdXRlID0gdGhpcy5leGVjdXRpb25TdGFjay5wb3AoKTtcbiAgICAgIG5vZGVUb0V4ZWN1dGUuZXhlY3V0ZSh0aGlzLmN0eCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzY2hlZHVsZU5vZGVzKCk6IHZvaWQge1xuICAgIHRoaXMuY3R4LmN1cnJlbnRHcmFwaC5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgaWYgKCFub2RlLmFsbERlcGVuZGVuY2llc1Jlc29sdmVkKCkpIHtcbiAgICAgICAgY29uc3QgaW5jb21pbmdFZGdlcyA9IG5vZGUuaW5jb21pbmdFZGdlcygpO1xuXG4gICAgICAgIGlmIChpbmNvbWluZ0VkZ2VzLnNvbWUoJCA9PiAkLmNyb3NzR3JhcGhFZGdlKCkpKSB7XG4gICAgICAgICAgY29uc3QgY3Jvc3NHcmFwaCA9IGluY29taW5nRWRnZXMuZmlsdGVyKGVkZ2UgPT4gZWRnZS5jcm9zc0dyYXBoRWRnZSgpKTtcbiAgICAgICAgICBjcm9zc0dyYXBoLmZvckVhY2goJCA9PiB0aGlzLnNjaGVkdWxlRGVwZW5kZW5jaWVzKCQsIFtdKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmN0eC5jdXJyZW50R3JhcGgubm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgIGlmIChub2RlLmFsbERlcGVuZGVuY2llc1Jlc29sdmVkKCkpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZU5vZGUobm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIHNjaGVkdWxlRGVwZW5kZW5jaWVzKGVkZ2U6IEVkZ2UsIHN0YWNrOiBBcnJheTxUeXBlTm9kZT4pOiB2b2lkIHtcbiAgICBpZiAoIWVkZ2UuaW5jb21pbmdUeXBlRGVmaW5lZCgpKSB7XG4gICAgICBpZiAoZWRnZS5zb3VyY2UucmVzdWx0VHlwZSgpKSB7XG4gICAgICAgIGVkZ2UucHJvcGFnYXRlVHlwZShlZGdlLnNvdXJjZS5yZXN1bHRUeXBlKCksIHRoaXMuY3R4KTtcbiAgICAgIH0gZWxzZSBpZiAoZWRnZS5zb3VyY2UuaW5jb21pbmdFZGdlcygpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVOb2RlKGVkZ2Uuc291cmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghc3RhY2suaW5jbHVkZXMoZWRnZS5zb3VyY2UpKSB7XG4gICAgICAgICAgc3RhY2sucHVzaChlZGdlLnNvdXJjZSk7XG4gICAgICAgICAgZWRnZS5zb3VyY2UuaW5jb21pbmdFZGdlcygpLmZvckVhY2goaW5jb21pbmdFZGdlID0+IHtcbiAgICAgICAgICAgIC8vQXZvaWQgc2VsZiByZWZlcmVuY2UgbG9vcFxuICAgICAgICAgICAgaWYgKGluY29taW5nRWRnZS5zb3VyY2UgIT0gZWRnZS50YXJnZXQpIHtcbiAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZURlcGVuZGVuY2llcyhpbmNvbWluZ0VkZ2UsIHN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN0eC5jdXJyZW50RXhlY3V0b3Iuc2NoZWR1bGVOb2RlKGVkZ2UudGFyZ2V0KTtcbiAgICB9XG4gIH1cblxuICBydW4oKTogdm9pZCB7XG4gICAgdGhpcy5zY2hlZHVsZU5vZGVzKCk7XG4gICAgdGhpcy5zdGFydCgpO1xuICAgIHRoaXMuY3R4LmVuZENvbnRleHQoKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZVJldHVyblR5cGUoXG4gIHR5cGVHcmFwaDogVHlwZUdyYXBoLFxuICBmdW5jdGlvbk5vZGU6IE5vZGVzLkZ1bmN0aW9uTm9kZSxcbiAgYXJnVHlwZXM6IFR5cGVbXSxcbiAgY3R4OiBUeXBlUmVzb2x1dGlvbkNvbnRleHRcbik6IFR5cGUgfCBudWxsIHtcbiAgY29uc3Qgc3ViR3JhcGg6IFR5cGVHcmFwaCA9IGN0eC5nZXRGdW5jdGlvblN1YkdyYXBoKGZ1bmN0aW9uTm9kZSwgYXJnVHlwZXMpO1xuXG4gIGlmIChzdWJHcmFwaCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHN1YkdyYXBoLmZpbmROb2RlKGZ1bmN0aW9uTm9kZSkucmVzdWx0VHlwZSgpO1xuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBGdW5jdGlvblR5cGUpIHtcbiAgICAgIC8vIFRISVMgU0hPVUxEIE5PVCBIQVBQRU5cbiAgICAgIHJldHVybiByZXN1bHQucmV0dXJuVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjb250ZXh0ID0gY3R4LmN1cnJlbnRQYXJzaW5nQ29udGV4dDtcblxuICAgIGNvbnN0IGRhdGFHcmFwaEJ1aWxkZXIgPSBuZXcgVHlwZUdyYXBoQnVpbGRlcihjdHgucGFyc2luZ0NvbnRleHQsIHR5cGVHcmFwaCk7XG5cbiAgICBjb25zdCBkYXRhR3JhcGg6IFR5cGVHcmFwaCA9IGRhdGFHcmFwaEJ1aWxkZXIuYnVpbGRGdW5jdGlvbk5vZGUoZnVuY3Rpb25Ob2RlLCBhcmdUeXBlcyk7XG5cbiAgICBjdHguYWRkRnVuY3Rpb25TdWJHcmFwaChmdW5jdGlvbk5vZGUsIGFyZ1R5cGVzLCBkYXRhR3JhcGgpO1xuICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uTm9kZS5mdW5jdGlvbk5hbWUubmFtZSArICcoJyArIGFyZ1R5cGVzLmpvaW4oJywnKSArICcpJztcbiAgICBjdHgucm9vdEdyYXBoLmFkZFN1YkdyYXBoKGRhdGFHcmFwaCwgZnVuY3Rpb25OYW1lKTtcbiAgICBjdHgubmV3RXhlY3V0b3JXaXRoQ29udGV4dChmdW5jdGlvbk5vZGUuY2xvc3VyZSwgZGF0YUdyYXBoLCBjb250ZXh0KS5ydW4oKTtcbiAgICBjb25zdCB2YWx1ZSA9IGRhdGFHcmFwaC5maW5kTm9kZShmdW5jdGlvbk5vZGUpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gdmFsdWUucmVzdWx0VHlwZSgpO1xuXG4gICAgaWYgKCFyZXN1bHQgfHwgY3R4LnBhcnNpbmdDb250ZXh0Lmhhc0Vycm9ycygpKSB7XG4gICAgICBjdHgucmVtb3ZlRnVuY3Rpb25TdWJHcmFwaChmdW5jdGlvbk5vZGUsIGFyZ1R5cGVzLCBkYXRhR3JhcGgpO1xuICAgICAgY3R4LnJvb3RHcmFwaC5yZW1vdmVTdWJHcmFwaChkYXRhR3JhcGgsIGZ1bmN0aW9uTmFtZSk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBGdW5jdGlvblR5cGUpIHtcbiAgICAgIC8vIFRISVMgU0hPVUxEIE5PVCBIQVBQRU5cbiAgICAgIHJldHVybiByZXN1bHQucmV0dXJuVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuIl19