"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NodeError_1 = require("./NodeError");
var NativeTypes;
(function (NativeTypes) {
    NativeTypes["i32"] = "i32";
    NativeTypes["i64"] = "i64";
    NativeTypes["f32"] = "f32";
    NativeTypes["f64"] = "f64";
    NativeTypes["anyfunc"] = "anyfunc";
    NativeTypes["func"] = "func";
    NativeTypes["block_type"] = "block_type";
    NativeTypes["void"] = "void";
    NativeTypes["boolean"] = "boolean";
    NativeTypes["i8"] = "i8";
    NativeTypes["u8"] = "u8";
    NativeTypes["i16"] = "i16";
    NativeTypes["u16"] = "u16";
    NativeTypes["u32"] = "u32";
    NativeTypes["u64"] = "u64";
})(NativeTypes = exports.NativeTypes || (exports.NativeTypes = {}));
// In _bytes_
const word = 4;
var sizeOf;
(function (sizeOf) {
    sizeOf[sizeOf["i32"] = word] = "i32";
    sizeOf[sizeOf["i64"] = word * 2] = "i64";
    sizeOf[sizeOf["f32"] = word] = "f32";
    sizeOf[sizeOf["f64"] = word * 2] = "f64";
    sizeOf[sizeOf["u64"] = word * 2] = "u64";
    sizeOf[sizeOf["u32"] = word] = "u32";
    sizeOf[sizeOf["u16"] = word >> 1] = "u16";
    sizeOf[sizeOf["boolean"] = word >> 2] = "boolean";
    sizeOf[sizeOf["u8"] = word >> 2] = "u8";
    sizeOf[sizeOf["i8"] = word >> 2] = "i8";
    sizeOf[sizeOf["i16"] = word >> 1] = "i16";
    sizeOf[sizeOf["anyfunc"] = word] = "anyfunc";
    sizeOf[sizeOf["func"] = word] = "func";
    sizeOf[sizeOf["block_type"] = word] = "block_type";
})(sizeOf = exports.sizeOf || (exports.sizeOf = {}));
class Type {
    getSize() {
        return sizeOf[this.nativeType];
    }
    get binaryenType() {
        switch (this.nativeType) {
            case NativeTypes.i32:
                return 'i32';
            case NativeTypes.u32:
                return 'i32';
            case NativeTypes.f32:
                return 'f32';
            case NativeTypes.f64:
                return 'f64';
            case NativeTypes.boolean:
            case NativeTypes.u8:
            case NativeTypes.i8:
            case NativeTypes.u16:
            case NativeTypes.i16:
            case NativeTypes.func:
                return 'i32';
            case NativeTypes.void:
                return undefined;
        }
    }
    equals(_otherType) {
        if (!_otherType)
            return false;
        return _otherType && this.nativeType == _otherType.nativeType && this.binaryenType == _otherType.binaryenType;
    }
    canBeAssignedTo(_otherType) {
        return this.equals(_otherType);
    }
    toString() {
        return `???<${NativeTypes[this.nativeType]}>`;
    }
}
exports.Type = Type;
class VoidType extends Type {
    constructor() {
        super();
        this.nativeType = NativeTypes.void;
    }
    toString() {
        return 'void';
    }
}
VoidType.instance = new VoidType();
exports.VoidType = VoidType;
class InvalidType extends VoidType {
    toString() {
        return 'INVALID_TYPE';
    }
}
InvalidType.instance = new InvalidType();
exports.InvalidType = InvalidType;
class FunctionType extends Type {
    constructor(internalName) {
        super();
        this.internalName = internalName;
        this.nativeType = NativeTypes.func;
    }
    acceptsTypes(types) {
        if (this.parameterTypes.length !== types.length)
            return false;
        return types.every(($, $$) => this.parameterTypes[$$].equals($));
    }
    equals(type) {
        if (!(type instanceof FunctionType))
            return false;
        if (this.parameterTypes.length != type.parameterTypes.length)
            return false;
        if (!this.returnType.equals(type.returnType))
            return false;
        if (this.parameterTypes.some(($, $$) => !$.equals(type.parameterTypes[$$])))
            return false;
        return true;
    }
    toString() {
        return `fun(${this.parameterTypes
            .map(($, $$) => {
            if (this.parameterNames[$$]) {
                return this.parameterNames[$$] + ': ' + $;
            }
            else {
                return $;
            }
        })
            .join(', ')}) -> ${this.returnType}`;
    }
}
exports.FunctionType = FunctionType;
class IntersectionType extends Type {
    constructor(of = []) {
        super();
        this.of = of;
        this.nativeType = NativeTypes.anyfunc;
    }
    toString() {
        return this.of.map($ => $.toString()).join(' & ');
    }
    simplify() {
        const newTypes = [];
        this.of.forEach($ => {
            if (!newTypes.some($1 => $1.equals($))) {
                newTypes.push($);
            }
        });
        if (newTypes.length === 1) {
            return newTypes[0];
        }
        else {
            const newType = new IntersectionType();
            newType.of = newTypes;
            return newType;
        }
    }
}
exports.IntersectionType = IntersectionType;
class TypeReference extends Type {
    constructor(referencedName, closure) {
        super();
        this.referencedName = referencedName;
        this.closure = closure;
    }
    resolveType(typeGraph) {
        const resolvedReference = this.closure.get(this.referencedName);
        const typeNode = typeGraph.findNode(resolvedReference.referencedNode);
        // TODO: verify referencedNode is a type declaration and not a variable name
        if (!typeNode) {
            throw new NodeError_1.AstNodeError('Node has no type node', resolvedReference.referencedNode);
        }
        if (!typeNode.resultType()) {
            throw new NodeError_1.AstNodeError(`Node ${resolvedReference.referencedNode.nodeName} has no resolved type`, resolvedReference.referencedNode);
        }
        return typeNode.resultType();
    }
    toString() {
        return `TypeRef(${this.referencedName})`;
    }
}
exports.TypeReference = TypeReference;
class UnionType extends Type {
    constructor(of = []) {
        super();
        this.of = of;
        this.nativeType = NativeTypes.anyfunc;
    }
    toString() {
        return this.of.map($ => $.toString()).join(' | ');
    }
    simplify() {
        const newTypes = [];
        this.of.forEach($ => {
            if (!newTypes.some($1 => $1.equals($))) {
                newTypes.push($);
            }
        });
        if (newTypes.length === 1) {
            return newTypes[0];
        }
        else {
            const newType = new UnionType();
            newType.of = newTypes;
            return newType;
        }
    }
}
exports.UnionType = UnionType;
class NativeType extends Type {
    constructor(nativeType) {
        super();
        this.nativeType = nativeType;
    }
    toString() {
        return NativeTypes[this.nativeType];
    }
}
exports.NativeType = NativeType;
class u8 extends NativeType {
    constructor() {
        super(NativeTypes.u8);
    }
}
exports.u8 = u8;
class bool extends NativeType {
    constructor() {
        super(NativeTypes.i32);
    }
    equals(_otherType) {
        if (!_otherType)
            return false;
        return _otherType && _otherType instanceof bool;
    }
    toString() {
        return NativeTypes.boolean;
    }
}
bool.instance = new bool();
exports.bool = bool;
class i32 extends NativeType {
    constructor() {
        super(NativeTypes.i32);
    }
}
exports.i32 = i32;
class u32 extends NativeType {
    constructor() {
        super(NativeTypes.u32);
    }
}
exports.u32 = u32;
class i16 extends NativeType {
    constructor() {
        super(NativeTypes.i16);
    }
}
exports.i16 = i16;
class u16 extends NativeType {
    constructor() {
        super(NativeTypes.u16);
    }
}
exports.u16 = u16;
class f32 extends NativeType {
    constructor() {
        super(NativeTypes.f32);
    }
}
exports.f32 = f32;
class f64 extends NativeType {
    constructor() {
        super(NativeTypes.f64);
    }
}
exports.f64 = f64;
class pointer extends NativeType {
    constructor() {
        super(NativeTypes.anyfunc);
    }
}
exports.pointer = pointer;
exports.InjectableTypes = {
    u8,
    boolean: bool,
    i32,
    u32,
    i16,
    u16,
    f32,
    f64,
    pointer,
    void: VoidType
};
function toConcreteType(type, ctx) {
    if (type instanceof TypeReference) {
        return type.resolveType(ctx.currentGraph);
    }
    return type;
}
exports.toConcreteType = toConcreteType;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ0eXBlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUNBLDJDQUEyQztBQU0zQyxJQUFZLFdBaUJYO0FBakJELFdBQVksV0FBVztJQUNyQiwwQkFBVyxDQUFBO0lBQ1gsMEJBQVcsQ0FBQTtJQUNYLDBCQUFXLENBQUE7SUFDWCwwQkFBVyxDQUFBO0lBQ1gsa0NBQW1CLENBQUE7SUFDbkIsNEJBQWEsQ0FBQTtJQUNiLHdDQUF5QixDQUFBO0lBQ3pCLDRCQUFhLENBQUE7SUFFYixrQ0FBbUIsQ0FBQTtJQUNuQix3QkFBUyxDQUFBO0lBQ1Qsd0JBQVMsQ0FBQTtJQUNULDBCQUFXLENBQUE7SUFDWCwwQkFBVyxDQUFBO0lBQ1gsMEJBQVcsQ0FBQTtJQUNYLDBCQUFXLENBQUE7QUFDYixDQUFDLEVBakJXLFdBQVcsR0FBWCxtQkFBVyxLQUFYLG1CQUFXLFFBaUJ0QjtBQUVELGFBQWE7QUFDYixNQUFNLElBQUksR0FBRyxDQUFDLENBQUM7QUFFZixJQUFZLE1BZVg7QUFmRCxXQUFZLE1BQU07SUFDaEIsdUJBQU0sSUFBSSxTQUFBLENBQUE7SUFDVix1QkFBTSxJQUFJLEdBQUcsQ0FBQyxTQUFBLENBQUE7SUFDZCx1QkFBTSxJQUFJLFNBQUEsQ0FBQTtJQUNWLHVCQUFNLElBQUksR0FBRyxDQUFDLFNBQUEsQ0FBQTtJQUNkLHVCQUFNLElBQUksR0FBRyxDQUFDLFNBQUEsQ0FBQTtJQUNkLHVCQUFNLElBQUksU0FBQSxDQUFBO0lBQ1YsdUJBQU0sSUFBSSxJQUFJLENBQUMsU0FBQSxDQUFBO0lBQ2YsMkJBQVUsSUFBSSxJQUFJLENBQUMsYUFBQSxDQUFBO0lBQ25CLHNCQUFLLElBQUksSUFBSSxDQUFDLFFBQUEsQ0FBQTtJQUNkLHNCQUFLLElBQUksSUFBSSxDQUFDLFFBQUEsQ0FBQTtJQUNkLHVCQUFNLElBQUksSUFBSSxDQUFDLFNBQUEsQ0FBQTtJQUNmLDJCQUFVLElBQUksYUFBQSxDQUFB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U0FBaUIsU0FBUSxVQUFVO0lBQ2pDO1FBQ0UsS0FBSyxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN6QixDQUFDO0NBQ0Y7QUFKRCxrQkFJQztBQUVELFNBQWlCLFNBQVEsVUFBVTtJQUNqQztRQUNFLEtBQUssQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDekIsQ0FBQztDQUNGO0FBSkQsa0JBSUM7QUFFRCxTQUFpQixTQUFRLFVBQVU7SUFDakM7UUFDRSxLQUFLLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3pCLENBQUM7Q0FDRjtBQUpELGtCQUlDO0FBRUQsU0FBaUIsU0FBUSxVQUFVO0lBQ2pDO1FBQ0UsS0FBSyxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN6QixDQUFDO0NBQ0Y7QUFKRCxrQkFJQztBQUVELGFBQXFCLFNBQVEsVUFBVTtJQUNyQztRQUNFLEtBQUssQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDN0IsQ0FBQztDQUNGO0FBSkQsMEJBSUM7QUFFWSxRQUFBLGVBQWUsR0FBRztJQUM3QixFQUFFO0lBQ0YsT0FBTyxFQUFFLElBQUk7SUFDYixHQUFHO0lBQ0gsR0FBRztJQUNILEdBQUc7SUFDSCxHQUFHO0lBQ0gsR0FBRztJQUNILEdBQUc7SUFDSCxPQUFPO0lBQ1AsSUFBSSxFQUFFLFFBQVE7Q0FDZixDQUFDO0FBRUYsd0JBQStCLElBQVUsRUFBRSxHQUEwQjtJQUNuRSxJQUFJLElBQUksWUFBWSxhQUFhLEVBQUU7UUFDakMsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQztLQUMzQztJQUVELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQztBQU5ELHdDQU1DIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2xvc3VyZSB9IGZyb20gJy4vY2xvc3VyZSc7XG5pbXBvcnQgeyBBc3ROb2RlRXJyb3IgfSBmcm9tICcuL05vZGVFcnJvcic7XG5pbXBvcnQgeyBUeXBlR3JhcGggfSBmcm9tICcuL3R5cGVzL1R5cGVHcmFwaCc7XG5pbXBvcnQgeyBUeXBlUmVzb2x1dGlvbkNvbnRleHQgfSBmcm9tICcuL3R5cGVzL1R5cGVQcm9wYWdhdG9yJztcblxuZXhwb3J0IHR5cGUgVmFsdHlwZSA9ICdpMzInIHwgJ2k2NCcgfCAnZjMyJyB8ICdmNjQnIHwgJ3UzMicgfCAnbGFiZWwnO1xuXG5leHBvcnQgZW51bSBOYXRpdmVUeXBlcyB7XG4gIGkzMiA9ICdpMzInLFxuICBpNjQgPSAnaTY0JyxcbiAgZjMyID0gJ2YzMicsXG4gIGY2NCA9ICdmNjQnLFxuICBhbnlmdW5jID0gJ2FueWZ1bmMnLFxuICBmdW5jID0gJ2Z1bmMnLFxuICBibG9ja190eXBlID0gJ2Jsb2NrX3R5cGUnLFxuICB2b2lkID0gJ3ZvaWQnLFxuXG4gIGJvb2xlYW4gPSAnYm9vbGVhbicsXG4gIGk4ID0gJ2k4JyxcbiAgdTggPSAndTgnLFxuICBpMTYgPSAnaTE2JyxcbiAgdTE2ID0gJ3UxNicsXG4gIHUzMiA9ICd1MzInLFxuICB1NjQgPSAndTY0J1xufVxuXG4vLyBJbiBfYnl0ZXNfXG5jb25zdCB3b3JkID0gNDtcblxuZXhwb3J0IGVudW0gc2l6ZU9mIHtcbiAgaTMyID0gd29yZCxcbiAgaTY0ID0gd29yZCAqIDIsXG4gIGYzMiA9IHdvcmQsXG4gIGY2NCA9IHdvcmQgKiAyLFxuICB1NjQgPSB3b3JkICogMixcbiAgdTMyID0gd29yZCxcbiAgdTE2ID0gd29yZCA+PiAxLFxuICBib29sZWFuID0gd29yZCA+PiAyLFxuICB1OCA9IHdvcmQgPj4gMixcbiAgaTggPSB3b3JkID4+IDIsXG4gIGkxNiA9IHdvcmQgPj4gMSxcbiAgYW55ZnVuYyA9IHdvcmQsXG4gIGZ1bmMgPSB3b3JkLFxuICBibG9ja190eXBlID0gd29yZFxufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVHlwZSB7XG4gIG5hdGl2ZVR5cGU6IE5hdGl2ZVR5cGVzO1xuICBnZXRTaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHNpemVPZlt0aGlzLm5hdGl2ZVR5cGVdO1xuICB9XG4gIGdldCBiaW5hcnllblR5cGUoKTogVmFsdHlwZSB7XG4gICAgc3dpdGNoICh0aGlzLm5hdGl2ZVR5cGUpIHtcbiAgICAgIGNhc2UgTmF0aXZlVHlwZXMuaTMyOlxuICAgICAgICByZXR1cm4gJ2kzMic7XG4gICAgICBjYXNlIE5hdGl2ZVR5cGVzLnUzMjpcbiAgICAgICAgcmV0dXJuICdpMzInO1xuICAgICAgY2FzZSBOYXRpdmVUeXBlcy5mMzI6XG4gICAgICAgIHJldHVybiAnZjMyJztcbiAgICAgIGNhc2UgTmF0aXZlVHlwZXMuZjY0OlxuICAgICAgICByZXR1cm4gJ2Y2NCc7XG5cbiAgICAgIGNhc2UgTmF0aXZlVHlwZXMuYm9vbGVhbjpcbiAgICAgIGNhc2UgTmF0aXZlVHlwZXMudTg6XG4gICAgICBjYXNlIE5hdGl2ZVR5cGVzLmk4OlxuICAgICAgY2FzZSBOYXRpdmVUeXBlcy51MTY6XG4gICAgICBjYXNlIE5hdGl2ZVR5cGVzLmkxNjpcbiAgICAgIGNhc2UgTmF0aXZlVHlwZXMuZnVuYzpcbiAgICAgICAgcmV0dXJuICdpMzInO1xuXG4gICAgICBjYXNlIE5hdGl2ZVR5cGVzLnZvaWQ6XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgZXF1YWxzKF9vdGhlclR5cGU6IFR5cGUpIHtcbiAgICBpZiAoIV9vdGhlclR5cGUpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gX290aGVyVHlwZSAmJiB0aGlzLm5hdGl2ZVR5cGUgPT0gX290aGVyVHlwZS5uYXRpdmVUeXBlICYmIHRoaXMuYmluYXJ5ZW5UeXBlID09IF9vdGhlclR5cGUuYmluYXJ5ZW5UeXBlO1xuICB9XG5cbiAgY2FuQmVBc3NpZ25lZFRvKF9vdGhlclR5cGU6IFR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5lcXVhbHMoX290aGVyVHlwZSk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYD8/Pzwke05hdGl2ZVR5cGVzW3RoaXMubmF0aXZlVHlwZV19PmA7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFZvaWRUeXBlIGV4dGVuZHMgVHlwZSB7XG4gIG5hdGl2ZVR5cGU6IE5hdGl2ZVR5cGVzID0gTmF0aXZlVHlwZXMudm9pZDtcblxuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAndm9pZCc7XG4gIH1cblxuICBzdGF0aWMgaW5zdGFuY2UgPSBuZXcgVm9pZFR5cGUoKTtcbn1cblxuZXhwb3J0IGNsYXNzIEludmFsaWRUeXBlIGV4dGVuZHMgVm9pZFR5cGUge1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ0lOVkFMSURfVFlQRSc7XG4gIH1cblxuICBzdGF0aWMgaW5zdGFuY2UgPSBuZXcgSW52YWxpZFR5cGUoKTtcbn1cblxuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uVHlwZSBleHRlbmRzIFR5cGUge1xuICBuYXRpdmVUeXBlOiBOYXRpdmVUeXBlcyA9IE5hdGl2ZVR5cGVzLmZ1bmM7XG5cbiAgY29uc3RydWN0b3IocHVibGljIGludGVybmFsTmFtZTogc3RyaW5nKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIHBhcmFtZXRlclR5cGVzOiBUeXBlW107XG4gIHBhcmFtZXRlck5hbWVzOiBzdHJpbmdbXTtcbiAgcmV0dXJuVHlwZTogVHlwZTtcblxuICBhY2NlcHRzVHlwZXModHlwZXM6IFR5cGVbXSkge1xuICAgIGlmICh0aGlzLnBhcmFtZXRlclR5cGVzLmxlbmd0aCAhPT0gdHlwZXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHR5cGVzLmV2ZXJ5KCgkLCAkJCkgPT4gdGhpcy5wYXJhbWV0ZXJUeXBlc1skJF0uZXF1YWxzKCQpKTtcbiAgfVxuXG4gIGVxdWFscyh0eXBlOiBUeXBlKSB7XG4gICAgaWYgKCEodHlwZSBpbnN0YW5jZW9mIEZ1bmN0aW9uVHlwZSkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAodGhpcy5wYXJhbWV0ZXJUeXBlcy5sZW5ndGggIT0gdHlwZS5wYXJhbWV0ZXJUeXBlcy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIXRoaXMucmV0dXJuVHlwZS5lcXVhbHModHlwZS5yZXR1cm5UeXBlKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0aGlzLnBhcmFtZXRlclR5cGVzLnNvbWUoKCQsICQkKSA9PiAhJC5lcXVhbHModHlwZS5wYXJhbWV0ZXJUeXBlc1skJF0pKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBmdW4oJHt0aGlzLnBhcmFtZXRlclR5cGVzXG4gICAgICAubWFwKCgkLCAkJCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJOYW1lc1skJF0pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJhbWV0ZXJOYW1lc1skJF0gKyAnOiAnICsgJDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gJDtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5qb2luKCcsICcpfSkgLT4gJHt0aGlzLnJldHVyblR5cGV9YDtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgSW50ZXJzZWN0aW9uVHlwZSBleHRlbmRzIFR5cGUge1xuICBuYXRpdmVUeXBlOiBOYXRpdmVUeXBlcyA9IE5hdGl2ZVR5cGVzLmFueWZ1bmM7XG5cbiAgY29uc3RydWN0b3IocHVibGljIG9mOiBUeXBlW10gPSBbXSkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5vZi5tYXAoJCA9PiAkLnRvU3RyaW5nKCkpLmpvaW4oJyAmICcpO1xuICB9XG5cbiAgc2ltcGxpZnkoKSB7XG4gICAgY29uc3QgbmV3VHlwZXM6IFR5cGVbXSA9IFtdO1xuICAgIHRoaXMub2YuZm9yRWFjaCgkID0+IHtcbiAgICAgIGlmICghbmV3VHlwZXMuc29tZSgkMSA9PiAkMS5lcXVhbHMoJCkpKSB7XG4gICAgICAgIG5ld1R5cGVzLnB1c2goJCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAobmV3VHlwZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gbmV3VHlwZXNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5ld1R5cGUgPSBuZXcgSW50ZXJzZWN0aW9uVHlwZSgpO1xuICAgICAgbmV3VHlwZS5vZiA9IG5ld1R5cGVzO1xuICAgICAgcmV0dXJuIG5ld1R5cGU7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBUeXBlUmVmZXJlbmNlIGV4dGVuZHMgVHlwZSB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWZlcmVuY2VkTmFtZTogc3RyaW5nLCBwdWJsaWMgY2xvc3VyZTogQ2xvc3VyZSkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICByZXNvbHZlVHlwZSh0eXBlR3JhcGg6IFR5cGVHcmFwaCk6IFR5cGUge1xuICAgIGNvbnN0IHJlc29sdmVkUmVmZXJlbmNlID0gdGhpcy5jbG9zdXJlLmdldCh0aGlzLnJlZmVyZW5jZWROYW1lKTtcbiAgICBjb25zdCB0eXBlTm9kZSA9IHR5cGVHcmFwaC5maW5kTm9kZShyZXNvbHZlZFJlZmVyZW5jZS5yZWZlcmVuY2VkTm9kZSk7XG5cbiAgICAvLyBUT0RPOiB2ZXJpZnkgcmVmZXJlbmNlZE5vZGUgaXMgYSB0eXBlIGRlY2xhcmF0aW9uIGFuZCBub3QgYSB2YXJpYWJsZSBuYW1lXG5cbiAgICBpZiAoIXR5cGVOb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgQXN0Tm9kZUVycm9yKCdOb2RlIGhhcyBubyB0eXBlIG5vZGUnLCByZXNvbHZlZFJlZmVyZW5jZS5yZWZlcmVuY2VkTm9kZSk7XG4gICAgfVxuICAgIGlmICghdHlwZU5vZGUucmVzdWx0VHlwZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgQXN0Tm9kZUVycm9yKFxuICAgICAgICBgTm9kZSAke3Jlc29sdmVkUmVmZXJlbmNlLnJlZmVyZW5jZWROb2RlLm5vZGVOYW1lfSBoYXMgbm8gcmVzb2x2ZWQgdHlwZWAsXG4gICAgICAgIHJlc29sdmVkUmVmZXJlbmNlLnJlZmVyZW5jZWROb2RlXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZU5vZGUucmVzdWx0VHlwZSgpO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBUeXBlUmVmKCR7dGhpcy5yZWZlcmVuY2VkTmFtZX0pYDtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVW5pb25UeXBlIGV4dGVuZHMgVHlwZSB7XG4gIG5hdGl2ZVR5cGU6IE5hdGl2ZVR5cGVzID0gTmF0aXZlVHlwZXMuYW55ZnVuYztcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgb2Y6IFR5cGVbXSA9IFtdKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm9mLm1hcCgkID0+ICQudG9TdHJpbmcoKSkuam9pbignIHwgJyk7XG4gIH1cblxuICBzaW1wbGlmeSgpIHtcbiAgICBjb25zdCBuZXdUeXBlczogVHlwZVtdID0gW107XG4gICAgdGhpcy5vZi5mb3JFYWNoKCQgPT4ge1xuICAgICAgaWYgKCFuZXdUeXBlcy5zb21lKCQxID0+ICQxLmVxdWFscygkKSkpIHtcbiAgICAgICAgbmV3VHlwZXMucHVzaCgkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChuZXdUeXBlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBuZXdUeXBlc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbmV3VHlwZSA9IG5ldyBVbmlvblR5cGUoKTtcbiAgICAgIG5ld1R5cGUub2YgPSBuZXdUeXBlcztcbiAgICAgIHJldHVybiBuZXdUeXBlO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTmF0aXZlVHlwZSBleHRlbmRzIFR5cGUge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgbmF0aXZlVHlwZTogTmF0aXZlVHlwZXMpIHtcbiAgICBzdXBlcigpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBOYXRpdmVUeXBlc1t0aGlzLm5hdGl2ZVR5cGVdO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyB1OCBleHRlbmRzIE5hdGl2ZVR5cGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihOYXRpdmVUeXBlcy51OCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIGJvb2wgZXh0ZW5kcyBOYXRpdmVUeXBlIHtcbiAgc3RhdGljIGluc3RhbmNlID0gbmV3IGJvb2woKTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihOYXRpdmVUeXBlcy5pMzIpO1xuICB9XG5cbiAgZXF1YWxzKF9vdGhlclR5cGU6IFR5cGUpIHtcbiAgICBpZiAoIV9vdGhlclR5cGUpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gX290aGVyVHlwZSAmJiBfb3RoZXJUeXBlIGluc3RhbmNlb2YgYm9vbDtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBOYXRpdmVUeXBlcy5ib29sZWFuO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBpMzIgZXh0ZW5kcyBOYXRpdmVUeXBlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoTmF0aXZlVHlwZXMuaTMyKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgdTMyIGV4dGVuZHMgTmF0aXZlVHlwZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKE5hdGl2ZVR5cGVzLnUzMik7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIGkxNiBleHRlbmRzIE5hdGl2ZVR5cGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihOYXRpdmVUeXBlcy5pMTYpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyB1MTYgZXh0ZW5kcyBOYXRpdmVUeXBlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoTmF0aXZlVHlwZXMudTE2KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgZjMyIGV4dGVuZHMgTmF0aXZlVHlwZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKE5hdGl2ZVR5cGVzLmYzMik7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIGY2NCBleHRlbmRzIE5hdGl2ZVR5cGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihOYXRpdmVUeXBlcy5mNjQpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBwb2ludGVyIGV4dGVuZHMgTmF0aXZlVHlwZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKE5hdGl2ZVR5cGVzLmFueWZ1bmMpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBJbmplY3RhYmxlVHlwZXMgPSB7XG4gIHU4LFxuICBib29sZWFuOiBib29sLFxuICBpMzIsXG4gIHUzMixcbiAgaTE2LFxuICB1MTYsXG4gIGYzMixcbiAgZjY0LFxuICBwb2ludGVyLFxuICB2b2lkOiBWb2lkVHlwZVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHRvQ29uY3JldGVUeXBlKHR5cGU6IFR5cGUsIGN0eDogVHlwZVJlc29sdXRpb25Db250ZXh0KSB7XG4gIGlmICh0eXBlIGluc3RhbmNlb2YgVHlwZVJlZmVyZW5jZSkge1xuICAgIHJldHVybiB0eXBlLnJlc29sdmVUeXBlKGN0eC5jdXJyZW50R3JhcGgpO1xuICB9XG5cbiAgcmV0dXJuIHR5cGU7XG59XG4iXX0=